import { ReactNode } from "react";
export enum MoveType {
  match,
}

export enum PushType {
  locateToSubgame,
}

export interface IMoveParams {
  namespace: string;
}

export interface IPushParams {
  matchingSet: Set<string>;
  namespace: string;
  subGameId: string;
}

export interface ICreateParams {}

export const ROOM_SIZE = 2;

export interface IGameState {
  matching: Map<string, Set<string>>;
}

export enum SubGameStatus {
  init,
  match,
  play,
  over,
}

export enum Page {
  intro,
  play,
  result,
  report,
}

export enum introPhases {
  currency,
  risk,
  securities,
}
export enum introSubPhases {
  intro,
  introDetail,
  question,
  reviewQuestion,
}

export interface IPlayerState {
  inited: Boolean;
  page: Page;
  subGameList: { namespace: string; status: SubGameStatus; id?: string }[];
  introPhases: {
    phases: introPhases;
    subPhases: introSubPhases;
    questionChose: Record<introPhases, number[]>;
  };
}

export interface introPhasesViewConfig {
  namespace: introPhases;
  intro: ReactNode;
  hasIntroDetail?: boolean;
  title: string;
  defQuestionList: questionState[];
}
export interface questionState {
  question: string;
  answer: string[];
  current: number;
  analyze: string;
}
const questionList: Record<introPhases, questionState[]> = {
  [introPhases.currency]: [
    {
      question: "1.下列各进制数中最小的数是()。",
      answer: ["A.110100B", "B.650", "C.36H", "D.55D"],
      current: 0,
      analyze:
        "将各进制数转化为十进制数，比较大小即可。A.110100B = 1×2^5 + 1×2^4 + 1×2^3 + 0×2^2 + 0×2^1 + 0×2^0 = 52 B.650 = 6×10^2 + 5×10^1 + 0×10^0 = 650 C.36H = 3×16^1 + 6×16^0 = 54 D.55D = 5×16^1 + 5×16^0 + 13×16^-1 = 85.8125 因此，最小的数是A",
    },
    {
      question:
        "2.在进位计数制中，当某一位的值达到某个固定量时，就要向高（）位产生进位。这个固定量就是该种进位计数制的",
      answer: ["A.阶码", "B.尾数", "C.原码", "D.基数"],
      current: 3,
      analyze:
        "这道题考查了进位计数制中的基本概念，即基数。进位计数制是一种数的表示法，它是人们在数的表示与计算中，根据实际需要所发明的一种计数方法。在进位计数制中，当某一位的值达到某个固定量时，就要向高位产生进位，这个固定量就是该种进位计数制的基数。",
    },
    {
      question: "3.在存储一个汉字内码的两个字节中，每个字节的最高位分别是",
      answer: ["A.0和1", "B.1和1", "C.O和O", "D.1和0"],
      current: 1,
      analyze:
        "这道题考查了汉字内码编码规则。在GB2312编码中，一个汉字占两个字节，每个字节有8位，共16位。在存储一个汉字内码的两个字节中，每个字节的最高位分别为1，表示该字节是汉字的第一个字节或第二个字节。因此，选项B.1和1是正确答案。",
    },
    // {
    //   question: "4.下列叙述中，正确的是",
    //   answer: [
    //     "A.汉字的计算机内码就是国标码 ",
    //     "B.存储器具有记忆能力，其中的信息任何时候都不会丢失",
    //     "C.所有十进制小数都能准确地转换为有限位二进制小数",
    //     "D.所有二进制小数都能准确地转换为十进制小数",
    //   ],
    //   current: 0,
    //   analyze:
    //     "正确的选项是A.汉字的计算机内码就是国标码。国标码是一种汉字内码编码规则，用于计算机内部对汉字的编码和存储。在计算机中，汉字的内码通常采用双字节编码，即一个汉字占两个字节，每个字节8位，共16位。国标码是一种常用的汉字内码编码规则，也是我国计算机处理汉字的标准。因此，选项A是正确的。选项B、C、D都是错误的。存储器虽然可以长期保存信息，但在某些情况下，例如断电或故障，其中的信息可能会丢失；不是所有的十进制小数都能准确地转换为有限位的二进制小数；同样地，不是所有的二进制小数都能准确地转换为十进制小数。",
    // },
    // {
    //   question: "5.地址从5ABH 到9ABH 的一段内存共有__个十进制字节。",
    //   answer: ["A.1024", "B.1025", "C.1000", "D.256"],
    //   current: 1,
    //   analyze:
    //     "由起始地址和末地址计算存储空间有两种方法：一是用十六进制计算：末地址-起始地址+1，然后转换成十进数。即：9ABH-5ABH+1=400H+1=4*162=1025；二是转换成十进制计算：9ABH-5ABH+1=9*162+10*16+11-5*162+10*16+11+1=1025。",
    // },
  ],
  [introPhases.risk]: [
    {
      question:
        "1.海明校验码是在个数据位之外增设个校验位，从而形成一个位的新的码字，使新的码字的码距比较均匀地拉大。与的关系是 （） 。",
      answer: ["A.2^k-1>=n+k", "B.2^n-1<=n+k", "C.n=k", "D.n-1<=k"],
      current: 0,
      analyze:
        "分析本题考查校验码方面的基础知识。海明码是一种多重（复式）奇偶检错编码。它将信息用逻辑形式编码，以便能够检错和纠错。用在海明码中的全部传输码字是由原来的信息和附加的奇偶校验位组成的。每一个这种奇偶位被编在传输码字的特定位置上。推导并使用长度为n位的码字的海明码，所需步骤如下:(1）确定最小的校验位数k，将它们记成D、D、…、D，每个校验位符合不同的奇偶测试规定。(2）原有信息和k个校验位一起编成长为n+k位的新码字。选择k校验位（0或1)以满足必要的奇偶条件。(3）对所接收的信息作所需的k个奇偶检查。(4）如果所有的奇偶检查结果均正确，则认为信息无错误。如果发现有一个或多个错了，则错误的位由这些检查的结果来唯一地确定。求海明码时的一项基本考虑是确定所需最少的校验位数k。考虑长度为n位的信息，若附加了k个校验位，则所发送的总长度为ntk。在接收器中要进行k个奇偶检查，每个检查结果或是真或是假。这个奇偶检查的结果可以表示成一个k位的二进制，它可以确定最多2种不同状态。这些状态中必有一个其所有奇偶测试都是真的，它便是判定信息正确的条件。于是剩下的（21）种状态可以用来判定误码的位置。于是导出以下关系:2-1≥n+k 参考答案A",
    },
    {
      question:
        "2.海明码利用奇偶性检错和纠错，通过在个数据位之间插入个校验位，扩大数据编码的码距。若=48，则应为 （）。",
      answer: ["A.4	", "B.5", "C.6", "D.7"],
      current: 2,
      analyze:
        "分析本题考查数据校验基础知识。设数据位是n位，校验位是k位，则n和k必须满足以下关系:2-1≥n+k 。若n=48，则k为6时可满足26-1≥48+6。海明码的编码规则如下。设k个校验位为P，P 1，…，Pr，n个数据位为Dn-1，Dn-2，…，D;，Do，对应的海明码为Hntk，Hntk-1，…，H，那么:P在海明码的第2”位置，即 H=P;，且j=2，数据位则依序从低到高占据海明码中剩下的位置。海明码中的任一位都是由若干个校验位来校验的。其对应关系如下:被校验的海明位的下标等于所有参与校验该位的校验位的下标之和，而校验位则由自身校验。参考答案c",
    },
    {
      question: "3.已知数据信息为16位，最少应附加 （） 位校验位，以实现海明码纠错。",
      answer: ["A.3", "B.4", "C.5", "D.6"],
      current: 2,
      analyze:
        "分析本题考查计算机系统基础知识。海明码是利用奇偶性来检错和纠错的校验方法。海明码的构成方法是:在数据位之间插入k个校验位，通过扩大码距来实现检错和纠错。设数据位是n位，校验位是k位，则n和 k必须满足以下关系:2k-1≥ n+k若数据信息为n=16位，则k=5是满足2-1≥n+k的最小值。参考答案c",
    },
    // {
    //   question:
    //     "4.海明码是一种纠错码，其方法是为需要校验的数据位增加若干校验位，使得校验位的值决定于某些被校位的数据，当被校数据出错时，可根据校验位的值的变化找到出错位，从而纠正错误。对于32位的数据，至少需要增加 （） 个校验位才能构成海明码。",
    //   answer: ["A.3", "B.4", "C.5", "D.6"],
    //   current: 3,
    //   analyze:
    //     "分析本题考查计算机系统基础知识。海明码的构成方法是在数据位之间的特定位置上插入k个校验位，通过扩大码距来实现检错和纠错。设数据位是n位，校验位是k位，则n和k必须满足以下关系:2-1≥n+k题中数据为32位，则k至少取6，才满足上述关系。海明码的编码规则如下。设k 个校验位为 Pt.Pt-1,…,P,，n个数据位为 Dn-1,Dn 2…,DI,Do，对应的海明码为Hntx.Hntk-1…,H，那么:①P在海明码的第2”位置，即H-P;，且j=2-，数据位则依序从低到高占据海明码中剩下的位置。海明码中的任何一位都是由若干个校验位来校验的。其对应关系如下:被校验的海明位的下标等于所有参与校验该位的校验位的下标之和，而校验位由自身校验。题目中数据位D;由P4Pz进行校验，因为Dz自右至左数是第10位（10=8+2)，P4Pz分别位于自右至左数的第8位和第2位。参考答案D",
    // },
    // {
    //   question: "5.利用海明码（Hamming Code）纠正单位错，如果有9位信息位，则需要加入（）位冗余位。",
    //   answer: ["A.4", "B.5", "C.7", "D.8"],
    //   current: 0,
    //   analyze:
    //     "分析为了纠正单位错，需要添加足够多的冗余位，使得每个信息位都有唯一的冗余位与之对应。对于9位信息位，可以使用4位海明码进行纠错，其中3位为信息位，1位为冗余位。因此，需要添加4位冗余位。因此，答案是4。",
    // },
  ],
  [introPhases.securities]: [
    {
      question: "1.在进行奇偶校验时,如果传输的数据为1101110,下面哪种说法是正确的()。",
      answer: ["A.奇校验,附加位为0", "B.奇校验,附加位为1", "C.偶校验,附加位为0", "D.偶校验,附加位为2"],
      current: 0,
      analyze:
        "在奇偶校验中，如果数据位中1的数量为奇数，则校验位为0；如果数据位中1的数量为偶数，则校验位为1。对于数据1101110，其中包含5个1和2个0，因此1的数量为奇数，校验位应该为0。因此，正确答案是A",
    },
    {
      question: "2.以下关于校验码的叙述中，正确的是()。",
      answer: [
        "A.海明码利用多组数位的奇偶性来检错和纠错",
        "B.海明码的码距必须大于等于1",
        "C.循环冗余校验码具有很强的检错和纠错能力",
        "D.循环冗余校验码的码距必定为1",
      ],
      current: 0,
      analyze:
        "本题考查校验码基础知识。一个编码系统中任意两个合法编码(码字)之间不同的二进数位数称为这两个码字的码距，而整个编码系统中任意两个码字的最小距离就是该编码系统的码距。为了使一个系统能检查和纠正一个差错，码间最小距离必须至少是3。海明码是一种可以纠正一位差错的编码，是利用奇偶性来检错和纠错的校验方法。海明码的基本意思是给传输的数据增加r个校验位，从而增加两个合法消息(合法码字)的不同位的个数(海明距离)。假设要传输的信息有m位，则经海明编码的码字就有n=m+r位。循环冗余校验码(CRC)编码方法是在k位信息码后再拼接厂位的校验码，形成长度为n位的编码，其特点是检错能力极强且开销小，易于用编码器及检测电路实现。在数据通信与网络中，通常众相当大，由一千甚至数千数据位构成一帧，而后采用 CRC码产生r位的校验位。它只能检测出错误，而不能纠正错误。一般取r=16，标准的 16位生成多项式有CRC-16=X16+x15+x2+1和CRC-CCITT=x16+x12+x5+1。一般情况下，r位生成多项式产生的CRC码可检测出所有的双错、奇数位错和突发长度小于等于r的突发错。用于纠错目的的循环码的译码算法比较复杂。",
    },
    {
      question: "3.循环冗余校验（CRC）是一种常用的校验传输技术，它的主要特点是什么？",
      answer: [
        "A.可以检测和纠正数据传输中的错误",
        "B.只能检测数据传输中的错误，不能纠正 ",
        "C.可以检测数据传输中的多个错误",
        "D.可以检测和纠正数据传输中的随机错误",
      ],
      current: 1,
      analyze:
        "正确答案是B。循环冗余校验（CRC）是一种只能检测数据传输中的错误，但不能纠正错误的校验传输技术。CRC通过在数据中添加冗余位，并使用特定的算法计算校验和来检测数据传输中是否发生了错误。如果发现校验和不匹配，则说明数据传输中发生了错误。选项A、C、D都不是CRC的特点，因此不正确。",
    },
    // {
    //   question: "4.下列哪种校验传输技术可以检测和纠正数据传输中的随机错误？",
    //   answer: ["A.循环冗余校验（CRC）", "B.海明码 ", "C.纵向冗余校验（VRC）", "D.地方政府债券"],
    //   current: 1,
    //   analyze:
    //     "正确答案是B。海明码是一种可以检测和纠正数据传输中的随机错误的纠错码。它通过在数据中添加冗余位，并使用特定的算法计算校验和来检测和纠正数据传输中的错误。选项A、C、D都不能检测和纠正随机错误，因此不正确。",
    // },
    // {
    //   question: "5.下列哪个选项是校验和的缺点？",
    //   answer: ["A.可以检测多个错误", "B.计算复杂度较低", "C.冗余位的数量较少", "D.不能纠正错误"],
    //   current: 3,
    //   analyze:
    //     "正确答案是D。校验和的一个缺点是不能纠正错误，它只能检测数据传输中是否发生了错误。如果校验和不匹配，则说明数据传输中发生了错误，但不能确定错误的位置和具体内容。选项A、B、C都不是校验和的缺点，因为它们都是校验和的优点。校验和可以检测多个错误，计算复杂度较低，并且可以使用较少的冗余位来进行校验。",
    // },
  ],
};

export const subGameViewConfigList: introPhasesViewConfig[] = [
  {
    namespace: introPhases.currency,
    intro:
      "信息融合可以被看作是一种多层次的计算机系统架构。在信息融合中，数据来源可以是来自不同传感器、不同设备或不同系统的原始数据，这些数据需要进行预处理、特征提取、数据清洗和数据格式转换等步骤，最终形成可以被计算机理解和处理的数据结构。" +
      "信息融合需要依赖于高速的数据传输和处理能力。例如，高速的总线、存储器和处理器可以提高数据的传输速度和处理速度，从而提高信息融合的效率和准确性。同时，信息融合还需要支持分布式计算和并行计算，以实现对海量数据的快速处理和分析。",
    title: "信息融合",
    hasIntroDetail: true,
    defQuestionList: questionList[introPhases.currency],
  },
  {
    namespace: introPhases.risk,
    intro:
      "海明码（Hamming Code）是一种用于检测和纠正数据传输中出现的错误的编码方案。它是由美国数学家理查德·海明（Richard Hamming）在20世纪50年代提出的。\n" +
      "\n" +
      "海明码的基本思想是通过在原始数据中添加冗余的校验位来检测和纠正传输中出现的错误。具体来说，海明码将原始数据分成多个数据块，并为每个数据块添加一定数量的校验位。这些校验位可以检测和纠正数据块中的错误，从而提高数据传输的可靠性。\n" +
      "\n" +
      "海明码的编码和解码过程都非常简单。编码时，将原始数据块和校验位按照一定的规则进行组合，形成一个更长的编码块。解码时，对编码块进行校验位的检查，从而检测和纠正其中的错误。",
    title: "海明码",
    defQuestionList: questionList[introPhases.risk],
  },
  {
    namespace: introPhases.securities,
    intro:
      "在数据传输过程中，由于通信渠道的噪声、干扰等原因，数据很容易出现错误。为了保证数据传输的可靠性，需要采用校验传输的方法对数据进行检测和纠错。\n" +
      "\n" +
      "校验传输是一种通过添加冗余数据来检测和纠正传输中的错误的方法。在校验传输中，发送方将原始数据进行处理，添加一定数量的冗余数据，形成一个带有校验信息的数据包，然后将数据包发送给接收方。接收方在收到数据包后，通过校验信息对数据进行检查和纠错，从而保证数据传输的可靠性。",
    title: "校验传输",
    defQuestionList: questionList[introPhases.securities],
  },
];

export function getSubGameViewConfig(namespace: introPhases) {
  return subGameViewConfigList.find((s) => s.namespace === namespace);
}
